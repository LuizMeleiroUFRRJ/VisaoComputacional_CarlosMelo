# -*- coding: utf-8 -*-
"""I2AI - Análise_de_Desmatamento_com_Landsat8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zdYY9r_vJy5gMCVuRn6_Ls9vP922RWo1

!["Sat"](https://sigmoidal.ai/wp-content/uploads/2023/07/Projeto-02-Analise-de-desmatamento-com-imagens-de-satelites.png)

Nos últimos anos, a acessibilidade aos dados geoespaciais tem aumentado drasticamente. Na última década, em particular, vimos uma explosão na disponibilidade de dados de satélite de alta qualidade, com muitos deles sendo oferecidos gratuitamente.

As imagens de satélite desempenham um papel importante, fornecendo dados cruciais para prever desastres, compreender as mudanças climáticas e garantir o fornecimento de água, entre muitos outros usos.

<center><img src="https://developers.google.com/static/earth-engine/images/Code_editor.png" height=350></center>

Essas imagens, provenientes de várias fontes como NASA, USGS, NOAA e ESA, incluem uma ampla gama de informações, como temperatura da superfície terrestre, vegetação e outros parâmetros biofísicos. Sendo assim, permitem uma compreensão mais detalhada do nosso planeta e a capacidade de monitorar e prever uma variedade de fenômenos naturais e induzidos pelo homem.

Neste notebook, iremos explorar o [Google Earth Engine (GEE)](https://developers.google.com/earth-engine/guides/python_install), uma plataforma que coloca esses recursos de dados à nossa disposição. O Google Earth Engine oferece um catálogo de imagens e dados ambientais vasto e atualizado, que inclui dados históricos de satélites de observação da Terra que remontam a décadas.

Neste projeto prático, nós desenvolveremos um *pipeline* que envolve a extração de diferentes bandas de dados do satélite Landsat 8. Usaremos esses dados para calcular o Índice de Vegetação por Diferença Normalizada (NDVI). Em seguida, após exportar as imagens resultantes como GeoTiff, nós realizaremos uma análise de desmatamento, um problema global crítico que tem implicações significativas para a biodiversidade, as mudanças climáticas e à vida humana.

# 1. Introdução ao Google Earth Engine (Python API)

Imagine que você está procurando um conjunto de dados meteorológicos. Pode parecer uma tarefa difícil, mas, na verdade, é tão fácil quanto encontrar a pizzaria mais próxima. Para comprovar isso, basta visitar o [Earth Engine Data Catalog](https://developers.google.com/earth-engine/datasets/catalog).

O **Earth Engine Data Catalog** é um catálogo público que inclui uma variedade de conjuntos de dados *raster* padrão de ciências da Terra que podem ser importados para o seu ambiente de script com um único clique. Nele você pode encontrar, por exemplo, conjuntos de dados como:

* [elevação global SRTM](https://developers.google.com/earth-engine/datasets/catalog/USGS_SRTMGL1_003) com resolução de 30 m
* [conjuntos de dados do OpenLandMap](https://developers.google.com/earth-engine/datasets/catalog/OpenLandMap_SOL_SOL_CLAY-WFRACTION_USDA-3A1A1A_M_v02) com propriedades do solo numa resolução de 250 m
* dados de temperatura, precipitação e evapotranspiração do [GRIDMET](https://developers.google.com/earth-engine/datasets/catalog/IDAHO_EPSCOR_GRIDMET).

Além disso, o catálogo também permite o upload de seus próprios dados raster ou dados vetoriais para uso privado ou compartilhamento em seus scripts. Os dados disponíveis incluem imagens de uma variedade de satélites e sensores, tornando-o um recurso inestimável para a análise geoespacial.

## 1.1 Acessar e autenticar no Google Earth Engine

Para acessar e aproveitar todos os recursos gratuitos disponibilizados, você precisa ter uma conta no Google e solicitar acesso à plataforma do Google Earth Engine. Uma vez que o acesso seja concedido, você pode começar a usar o Editor de Código do Google Earth Engine para escrever e executar scripts para acessar, analisar e visualizar os dados disponíveis.
"""

# Commented out IPython magic to ensure Python compatibility.
# Importamos as bibliotecas necessárias
import ee
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Esta linha permite que os gráficos sejam exibidos diretamente no notebook
# %matplotlib inline

# Configuramos a biblioteca matplotlib para usar 'gray' como o mapa de cores padrão para imagens
plt.rcParams['image.cmap'] = 'gray'

# Importamos a biblioteca gdal da osgeo, usada para manipular arquivos geoespaciais
from osgeo import gdal

# disparar o fluxo de autenticação
ee.Authenticate()

# inicializar a biblioteca
ee.Initialize(project='my-project')

print(ee.Image("NASA/NASADEM_HGT/001").get("title").getInfo())

ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20201028')

"""## 1.2 Extrair imagens (GeoTiff) do Google Earth Engine

Extrair imagens do Google Earth Engine envolve a execução de scripts para solicitar e processar dados de imagens de satélite. A plataforma do Google Earth Engine permite que você selecione uma coleção de imagens específica, aplique filtros temporais e espaciais para selecionar as imagens que atendam às suas necessidades e, em seguida, aplique algoritmos de processamento de imagem para manipular os dados da imagem. Você pode, por exemplo, extrair a vegetação ou dados de cobertura do solo, realizar análises de mudança ao longo do tempo, entre outras funções.
"""

def cloud_mask_l8(image):
    qa = image.select('QA_PIXEL')

    # Bits 3 and 5 are cloud shadow and cloud, respectively.
    cloudShadowBitMask = 1 << 3
    cloudsBitMask = 1 << 5

    # Both flags should be set to zero, indicating clear conditions.
    mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0) \
             .And(qa.bitwiseAnd(cloudsBitMask).eq(0))

    return image.updateMask(mask)

# Importa a coleção USGS Landsat 8 Level 2, Collection 2, Tier 1
# lc = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')

# Define um polígono em torno de Araraquara, São Paulo.
geometry = ee.Geometry.Polygon(
    [[  [-48.288819426780464, -21.693933254964236],
        [-48.288819426780464, -21.890949957071484],
        [-48.005618226433, -21.890949957071484],
        [-48.005618226433, -21.693933254964236]]],
        None,
        False)

# Define os parâmetros para Landsat8.
landsat8_params = {
  "bands": ['SR_B4', 'SR_B3', 'SR_B2'],
  "min": 0.0,
  "max": 30000.0,
  "gamma": 1.0
}

# Filtra a imagem da coleção do Landsat 8 pelo ano de 2013 e aplica a máscara de nuvens.
dataset13 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterDate('2013-01-01', '2013-12-31').map(cloud_mask_l8)
lansat13 = dataset13.median().clip(geometry)

# Filtra a imagem da coleção do Landsat 8 pelo ano de 2018 e aplica a máscara de nuvens.
dataset18 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterDate('2018-01-01', '2018-12-31').map(cloud_mask_l8)
lansat18 = dataset18.median().clip(geometry)

# Filtra a imagem da coleção do Landsat 8 pelo ano de 2023 e aplica a máscara de nuvens.
dataset23 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterDate('2023-01-01', '2023-12-31').map(cloud_mask_l8)
lansat23 = dataset23.median().clip(geometry)

"""## 1.3 Exibir imagens de satélite em mapas

Uma das principais vantagens do Google Earth Engine é sua capacidade de visualizar dados de sensoriamento remoto de maneira eficaz. Após a seleção e o processamento dos dados da imagem, você pode exibir as imagens de satélite em um mapa interativo. Isso é feito adicionando as imagens processadas como camadas em um Mapa do Google Earth Engine. Este mapa pode ser explorado e manipulado interativamente, permitindo uma visão clara e detalhada dos dados.
"""

import folium

def add_ee_layer(self, ee_image_object, vis_params, name):
    """
    Adiciona uma camada de imagem do Google Earth Engine a um mapa do folium.

    Args:
        self (object): Objeto do mapa folium ao qual a camada será adicionada.
        ee_image_object (ee.image.Image): Imagem do Google Earth Engine para ser adicionada ao mapa folium.
        vis_params (dict): Parâmetros de visualização para a imagem.
            Este dicionário deve conter pelo menos uma propriedade 'bands'.
            Por exemplo, { 'bands': ['SR_B4', 'SR_B3', 'SR_B2'], 'max': 0.3 }.
        name (str): Nome da camada que será adicionada.

    Retorna:
        None

    Exemplo:
        # Define um mapa folium
        mapa = folium.Map(location=[-15.783333, -47.866667], zoom_start=12)

        # Imagem do GEE
        imagem = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_220071_20170805')

        # Parâmetros de visualização
        vis = { 'bands': ['B4', 'B3', 'B2'], 'max': 0.3 }

        # Adicione a imagem ao mapa
        mapa.add_ee_layer(imagem, vis, 'Brasilia Landsat')

        # Exibe o mapa
        display(mapa)

    """
    map_id_dict = ee.Image(ee_image_object).getMapId(vis_params)
    folium.raster_layers.TileLayer(
        tiles=map_id_dict['tile_fetcher'].url_format,
        attr='Map Data &copy; <a href="https://earthengine.google.com/">Google Earth Engine</a>',
        name=name,
        overlay=True,
        control=True
    ).add_to(self)

# Adiciona o método de desenho do Google Earth Engine ao folium.
folium.Map.add_ee_layer = add_ee_layer

# Centraliza o mapa em Araraquara, São Paulo
map = folium.Map(location = (-21.7845, -48.1610), zoom_start = 12)

# Adicionando as imagens geradas ao mapa.
map.add_ee_layer(lansat13, landsat8_params, '2013')
map.add_ee_layer(lansat18, landsat8_params, '2018')
map.add_ee_layer(lansat23, landsat8_params, '2023')

# Adiciona um painel de controle de camadas ao mapa.
map.add_child(folium.LayerControl())

# Exibe o mapa.
display(map)

"""## 1.4 Salvar imagens do Google Earth como GeoTiff

O Google Earth Engine permite exportar dados processados, incluindo imagens de satélite, em uma variedade de formatos. Um dos formatos mais comuns é o GeoTiff, que é um formato de imagem TIFF que inclui metadados geoespaciais, permitindo que a imagem seja usada em sistemas de informação geográfica (GIS). Para salvar imagens como GeoTiff, você precisa definir uma tarefa de exportação no Editor de Código do Google Earth Engine e escolher o Google Drive como destino da exportação. A imagem processada será salva em seu Google Drive, pronto para ser baixado e usado em outras análises ou visualizações GIS.
"""

# Define um polígono com base nas novas coordenadas
geometry = ee.Geometry.Polygon(
    [[  [-52.989154807509664, -5.346181657991835],
        [-53.23098399897127, -5.346181657991835],
        [-53.23098399897127, -5.619155178370789],
        [-52.989154807509664, -5.619155178370789]]],
        None,
        False)

# Define os parâmetros para Landsat8.
landsat8_params = {
  "bands": ['SR_B4', 'SR_B3', 'SR_B2'],
  "min": 0.0,
  "max": 30000.0,
  "gamma": 1.0
}

# Filtra a imagem da coleção do Landsat 8 pelo ano de 2013 e aplica a máscara de nuvens.
dataset13 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterDate('2013-01-01', '2013-12-31').map(cloud_mask_l8)
lansat13 = dataset13.median().clip(geometry)

# Filtra a imagem da coleção do Landsat 8 pelo ano de 2018 e aplica a máscara de nuvens.
dataset18 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterDate('2018-01-01', '2018-12-31').map(cloud_mask_l8)
lansat18 = dataset18.median().clip(geometry)

# Filtra a imagem da coleção do Landsat 8 pelo ano de 2023 e aplica a máscara de nuvens.
dataset23 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterDate('2023-01-01', '2023-12-31').map(cloud_mask_l8)
lansat23 = dataset23.median().clip(geometry)

task_config = {
  'folder': 'deforestation',
  'scale': 30,
  'region': geometry,
  'fileFormat': 'GeoTIFF',
  'maxPixels': 1e9,
  'formatOptions': {
    'cloudOptimized': True
  }
}

task1 = ee.batch.Export.image.toDrive(lansat13, description= '2013api', **task_config)
task2 = ee.batch.Export.image.toDrive(lansat18, description= '2018api', **task_config)
task3 = ee.batch.Export.image.toDrive(lansat23, description= '2023api', **task_config)

task1.start()
task2.start()
task3.start()

task1.status()

task1.status()

task1.status()

from google.colab import drive
drive.mount('/content/drive')

"""# 2. Geospatial Data Abstraction Library

A GDAL, Biblioteca de Abstração de Dados Geoespaciais, é uma ferramenta valiosa para trabalhar com formatos de dados geoespaciais raster e vetoriais. O pacote GDAL Python fornece uma série de ferramentas que permitem programar e manipular esses dados de forma eficiente.

Um conceito importante na manipulação de imagens geoespaciais é o de **banda raster**. Imagens coloridas comuns geralmente têm 3 bandas raster, que representam os componentes de intensidade de luz azul, verde e vermelha. No entanto, uma banda raster pode conter qualquer conjunto de valores de células que representem a mesma área espacial, não se limitando apenas às informações de intensidade de luz.

Extrair dados raster através da GDAL é feito uma banda por vez. A função `GetRasterBand()` nos permite extrair uma única banda raster da imagem GeoTiff.

### Sintaxe da Função
```python
band = dataset.GetRasterBand( n )
```

A função possui **1 argumento de entrada obrigatório**:

1. `n` é o número do canal a ser extraído.

Para saber mais, você pode consultar a [documentação do GDAL](https://gdal.org/api/python/osgeo.gdal.html).

Neste exemplo, estamos trabalhando com uma imagem GeoTIFF do Landsat8 que contém diversas bandas, listadas abaixo:

1. Coastal/Aerosol
2. Blue
3. Green
4. Red
5. Near Infrared
6. Shortwave Infrared 1
7. Shortwave Infrared 2
8. Panchromatic
9. Cirrus
10. Thermal Infrared 1
11. Thermal Infrared 2

Vamos visualizar cada uma dessas bandas para melhor compreensão dos dados.


"""

# Usamos gdal para abrir um arquivo geoespacial específico
ds = gdal.Open('/content/drive/MyDrive/deforestation/2013api.tif')

# Criamos um dicionário que mapeia os números das bandas para seus nomes descritivos
band_names = {
    1: "Coastal/Aerosol",
    2: "Blue",
    3: "Green",
    4: "Red",
    5: "Near Infrared",
    6: "Shortwave Infrared 1",
    7: "Shortwave Infrared 2",
    8: "Panchromatic",
    9: "Cirrus",
    10: "Thermal Infrared 1",
    11: "Thermal Infrared 2",
}

# Criamos uma grade de subplots com 4 linhas e 3 colunas e definimos o tamanho da figura
fig, axs = plt.subplots(4, 3, figsize=(20, 15))

# Iteramos sobre cada banda e nome no dicionário band_names
for band, name in band_names.items():
    # Identificamos o subplot apropriado no qual plotar
    ax = axs[(band - 1) // 3, (band - 1) % 3]
    # Lemos os dados da banda atual como um array e os exibimos na imagem
    im = ax.imshow(ds.GetRasterBand(band).ReadAsArray())
    # Adicionamos uma barra de cores à imagem
    fig.colorbar(im, ax=ax)
    # Definimos o título do subplot com o nome da banda
    ax.set_title(name)

# Usamos tight_layout para garantir que os subplots não se sobreponham
plt.tight_layout()

# Exibimos a figura
plt.show()

"""# 3. Índice de Diferença Normalizada da Vegetação (NDVI)

O **Índice de Diferença Normalizada da Vegetação** ou NDVI é um índice que é utilizado para demonstrar a diferença entre a refletância visível e próxima do infravermelho da cobertura vegetal e **pode ser usado para estimar a densidade de verde em uma área de terra**.

O NDVI é calculado conforme a seguinte fórmula:

$$
NDVI = \frac{(NIR - RED)}{(NIR  + RED)}
$$

onde `RED` e `NIR` representam as medidas de refletância espectral adquiridas nas regiões vermelha (visível) e próxima do infravermelho, respectivamente. O índice NDVI para uma área com vegetação deve estar entre 0.3 (vegetação leve) a 0.8 (vegetação densa). Nuvens terão um índice negativo, enquanto solo e corpos de água terão valores positivos baixos. Usaremos essas informações para estimar a vegetação de uma determinada região.

Em valores normalizados, ou seja, entre (0, 255), o intervalo de interesse corresponde às intensidades compreendidas entre 165 e 230.

**Região Próxima ao Infravermelho (NIR)**

A região **NIR** tem um comprimento de onda de 0.76 - 0.90 µm. A vida vegetal absorve luz visível de 0.4 µm (luz azul) até 0.7 µm (luz vermelha) para fotossíntese, com absorção máxima em ambas as extremidades deste espectro. Vemos as plantas como verdes porque elas normalmente não absorvem os comprimentos de onda verdes da luz (~0.5 µm) no meio desta faixa. No entanto, isso torna o canal verde menos preciso para a detecção de vegetação porque está dentro da gama completa de comprimentos de onda utilizados para a fotossíntese. Por outro lado, as plantas refletem fortemente a luz próxima do infravermelho (de 0.7 a 1.1 µm). Este fato é explorado no cálculo do NDVI.

"""

def get_NDVI(ds):
    '''
    Calcula o Índice de Vegetação da Diferença Normalizada (NDVI) para uma imagem.

    Argumentos:
    ds -- Um objeto de conjunto de dados GDAL aberto que representa a imagem

    Retorna:
    ndvi -- Uma matriz numpy representando o NDVI da imagem
    '''
    r = ds.GetRasterBand(4).ReadAsArray()   # Banda Vermelha é a 4ª
    nir = ds.GetRasterBand(5).ReadAsArray() # Banda NIR é a 5ª
    ndvi = (nir - r)/(nir + r)
    ndvi = normalize255(ndvi)
    return ndvi

def normalize255(ndvi):
    '''
    Normaliza uma matriz de NDVI para a faixa de 0 a 255.

    Argumentos:
    ndvi -- Uma matriz numpy representando o NDVI

    Retorna:
    ndvi -- A matriz NDVI normalizada
    '''
    ndvi = ndvi + 1
    ndvi = (ndvi / 2) * 255
    return ndvi

def get_NDVI_mask(ndvi):
    '''
    Cria uma máscara de limiar para áreas de vegetação em uma matriz de NDVI.

    Argumentos:
    ndvi -- Uma matriz numpy representando o NDVI

    Retorna:
    mask -- Uma matriz binária onde os valores de 1 representam vegetação
    '''
    _, mask = cv2.threshold(ndvi, 170, 255, cv2.THRESH_BINARY)
    return mask

def percent_forest(mask):
    '''
    Calcula a porcentagem de pixels de vegetação em uma máscara.

    Argumentos:
    mask -- Uma matriz binária onde os valores de 1 representam vegetação

    Retorna:
    percent -- A porcentagem de pixels de vegetação
    '''
    c = cv2.countNonZero(mask)
    t = mask.shape[0] * mask.shape[1]
    return round((c / t) * 100, 4)

def plot_NDVI(path):
    '''
    Plota o NDVI e a máscara de vegetação de uma imagem e exibe a porcentagem de vegetação.

    Argumentos:
    path -- O caminho para o arquivo da imagem
    '''
    ds = gdal.Open(path)
    ndvi = get_NDVI(ds)
    ndvi_mask = get_NDVI_mask(ndvi)

    year = path.split('.')[0][:4]
    fig = plt.figure(figsize = (20, 5))
    fig = plt.subplot(1, 2, 1)
    plot = plt.imshow(ndvi, cmap = "gray")
    plt.colorbar()
    plt.title(year + ": " + "NDVI")
    plt.xticks([]), plt.yticks([])
    fig = plt.subplot(1, 2, 2)
    plot = plt.imshow(ndvi_mask, cmap = "gray");
    plt.title(str(percent_forest(ndvi_mask)) + "%")
    plt.xticks([]), plt.yticks([])
    plt.show()

plot_NDVI("/content/drive/MyDrive/deforestation/2013api.tif")

files = [
    "/content/drive/MyDrive/deforestation/2013api.tif",
    "/content/drive/MyDrive/deforestation/2023api.tif"
]

for file in files:
    plot_NDVI(file)

