# -*- coding: utf-8 -*-
"""I2AI - 1_Kernels_e_Filtros.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10KS9qe8Dks2gAf_d5pMRd-twX2696IJH

# Kernels e Filtros no OpenCV


**OpenCV** (Open Source Computer Vision Library) √© uma biblioteca *open source* para **Vis√£o Computacional** e **Machine Learning**. O OpenCV foi desenvolvido para facilitar uma innfraestrutura comum para aplica√ß√µes de Vis√£o Computacional e acelerar o uso de percepc√£o de m√°quinas em produtos comerciais.

<p align="center"><img src="https://miro.medium.com/max/3200/0*7s3HcYYvpnUhzDkG.png" width="60%"></p>

Nessa aula, vamos seguir nos aprofundando um pouco mais nessa biblioteca. Dessa vez, vamos trabalhar com Kernels e Filtros, que v√£o nos ajudar a manipular imagens atrav√©s da biblioteca.

Se voc√™ quiser ir mais a fundo, a [documenta√ß√£o oficial](https://docs.opencv.org/master/d3/dc1/tutorial_basic_linear_transform.html) √© bastante completa, e ajuda a entender ainda melhor tudo que est√° acontecendo por tr√°s das mudan√ßas de contraste e brilho que vamos fazer a seguir.
"""

!wget https://raw.githubusercontent.com/carlosfab/visao-computacional/main/data/carlos.png
!wget https://raw.githubusercontent.com/carlosfab/visao-computacional/main/data/carlos.jpg

# importando os pacotes necess√°rios
import cv2
import numpy as np
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt

"""Ap√≥s importar os pacotes, vamos carregar nossas imagens e come√ßar a manipula√ß√£o delas."""

# importar imagens
img0 = cv2.imread("carlos.jpg")
img1 = cv2.imread("carlos.png")

"""Sempre importante visualizar a imagem e verificar que tudo foi carregado com sucesso."""

# visualizando a imagem
cv2_imshow(img0)

"""## Filtros e Opera√ß√µes Aritm√©ticas

O filtro na verdade √© uma pequena matriz que usamos para deixar a imagem mais n√≠tida ou borrada, por exemplo. Para fazer isso, precisamos fazer uma opera√ß√£o de convolu√ß√£o.

Vamos ver, na pr√°tica o que seria uma convolu√ß√£o, em termos simples.

Por exemplo, temos uma matriz de 6x6 pixels que repesenta nossa imagem. O pr√≥ximo passo √© fazer uma opera√ß√£o de convolu√ß√£o com filtro 3x3. O produto final desse processo de convolu√ß√£o ser√° uma matriz 4x4. N√≥s calculamos os elementos da matriz inicial (imagem) e pegamos o produto de cada elemento correspondente e os juntamos, como voc√™ pode ver abaixo.

<p align="center"><img src="http://media5.datahacker.rs/2018/10/multiplication_obojeno_new-1024x370.png" width="60%"></p>

<p align="center"><img src="https://miro.medium.com/max/294/1*BMngs93_rm2_BpJFH2mS0Q.gif" width="30%"></p>

Ap√≥s avaliar a e excpress√£o acima n√≥s obtemos o resulto de -5. Esse ser√° o valor do pixel naquela posi√ß√£o na nossa imagem com o filtro aplicado. Ent√£o, n√≥s vamos movendo o filtro ao longo da imagem e vamos criando a imagem pronta.

Note que o nosso filtro √© uma matriz com a mesma altura e largura (3√ó3, 5√ó5, 9√ó9). Sempre usamos n√∫meros √≠mparespois precisamos ter um pixel ao centro dessa matriz.

Agora que temos uma intui√ß√£o de como a matriz funciona, vamos ver ela em a√ß√£o na pr√°tica.

"""

# utilizando o ones do numpy para criar o filtro
filtro_1 = np.ones(img0.shape, dtype=np.uint8) * 110

# aplicando o filtro √† imagem
somada = cv2.add(img0, filtro_1)

# mostrando a imagem com filtro
cv2_imshow(somada)

"""Esse primeiro filtro nos permitiu aumentar o brilho em toda a imagem, pois adicionamos o valor do filtro √† nossa imagem original.

Para escurecer a imagem, vamos fazer a opera√ß√£o contr√°ria, diminuindo os valor dos nossos pixels.
"""

# criando filtro
filtro_2 = np.ones(img0.shape, dtype=np.uint8) * 110

# aplicando filtro
subtraida = cv2.subtract(img0, filtro_1)

# imagem com filtro
cv2_imshow(subtraida)

"""### Blurring
Nas opera√ß√µes acima, n√≥s est√°vamos tratando apenas de um canal, o que n√£o √© o mais comum quando lidamos com imagens, que normalmente est√£o no padr√£o **RGB** (Red, Blue, Green). Por isso, precisamos de outra forma de lidar com essas imagens.

Quando pensamos em canais como sendo uma "vis√£o" da imagem como um todo, dando √™nfase ou escondendo determinadas partes de acordo com as caracter√≠sticas de cada canal.


<p align="center"><img src="https://miro.medium.com/max/1000/1*k8P28Ayl-5hOqIMSv-qosw.jpeg" width="70%"></p>

Por isso, uma distin√ß√£o de termos se faz chave aqui: quando falamos de 1 canal, os termos filtro e kernel s√£o praticamente intercambi√°veis, mas em geral, quando falamos de mais canais, eles s√£o bem diferentes.

Cada filtro, na verdade, √© uma cole√ß√£o de kernels, havendo um kernel para cada canal de input para a camada, e cada kernel sendo √∫nico. Cada filtro em uma camada convolucional produz um e apenas um canal de output, e eles o fazem assim:

<p align="center"><img src="https://miro.medium.com/max/1000/1*8dx6nxpUh2JqvYWPadTwMQ.gif" width="70%"></p>

Cada um dos kernels do filtro "anda" por cima de seu respectivo canal de input, produzindo uma vers√£o processada de cada um. √â importante lembrar que alguns kernels podem ter pesos mais fortes que outros, o que resultaria em √™nfases em determinados canais, ou um canal ser mais sens√≠vel a mudan√ßas que outros.

<p align="center"><img src="https://miro.medium.com/max/1000/1*CYB2dyR3EhFs1xNLK8ewiA.gif" width="70%"></p>

Ent√£o, cada uma das vers√µes processadas por cada canal s√£o somadas, formando um canal √∫nico. Os kernels de um filtro produzem uma vers√£o para cada canal, e o filtro, como um todo, produz um canal como output.

<p align="center"><img src="https://miro.medium.com/max/294/1*RYYucIh3U-YFxrIkyQKzRw.gif" width="30%"></p>

Por fim, temos um *bias*, ou um vi√©s, peso. A forma que o *bias* funciona √© que cada output de filtro possui um vi√©s. Esse vi√©s √© adicionado ao canal obtido como output at√© agora e produz o output final do canal.

Portanto, quando falamos em qualquer n√∫mero de filtros, a forma de trabalho ser√° id√™ntica: Cada filtro processa o input por si s√≥, juntamos diferentes conjuntos de kernels com um vi√©s atrav√©s do processo descrito acima, produzindo um canal de output √∫nico. Ent√£o, eles s√£o concatenados para produzir um output geral final, com o n√∫mero de canais sendo o n√∫mero de filtros. Normalmente, tamb√©m √© aplicada uma n√£o-linearidade passando esse input por outra camada de convolu√ß√£o, o que repete o processo.

Vamos ver como isso funciona na pr√°tica.

"""

# criando o kernel
kernel_blur = np.ones((3,3), np.float32) / 9

# aplicando o filtro
blurred = cv2.filter2D(img0, -1, kernel_blur)

# mostrando a imagem com filtro
cv2_imshow(blurred)

"""Aqui, podemos ver o resultado do filtro, que foi utilizado para emba√ßar a imagem.

Tamb√©m podemos aumentar a "for√ßa" desse efeito, mudando o par√¢metro pelo qual a matriz √© dividida.
"""

# criando o kernel
kernel_blur = np.ones((9,9), np.float32) / 81

# aplicando o filtro
blurred = cv2.filter2D(img0, -1, kernel_blur)

# verificando o resultado
cv2_imshow(blurred)

"""Como podemos ver, a foto est√° bem mais emba√ßada com o nosso filtro mais forte.

### Gaussian Blur

Outra forma de aplicar um *blur*, um emba√ßado na nossa imagem, seria o ***Gaussian Blur***. Esse filtro √© um pouco mais complexo, mas √© o tipo de kernel mais usado para processamento de imagens.

Para a cria√ß√£o desse filtro n√≥s usamos a **Fun√ß√£o Gaussiana**. Essa fun√ß√£o representa a probabilidade de eventos serem centrdos ao redor do valor da m√©dia. Al√©m disso, o desvio padr√£o (ùúé) dessa fun√ß√£o controla qu√£o ampla ser√° essa distribui√ß√£o. Ao tirar amostras de valores dessa fun√ß√£o, n√≥s consguirmos coeficientes para uma matriz de filtragem Gaussiana. O efeito de diferentes desvios padr√£o podem ser observados nas imagens a seguir.

<p align="center"><img src="http://media5.datahacker.rs/2020/05/image5.png" width="50%" ></p>
<center> Imagem 2D</center>

<p align="center"><img src="http://media5.datahacker.rs/2020/04/OIWce-768x576.png" width="50%" ></p>
<center> Imagem 3D</center>

Agora que temos uma intui√ß√£o no assunto, vamos ver como tudo isso fica na pr√°tica.
"""

# utilizando o GaussianBlur, que j√° √© implementado no OpenCV
gaussian_blurred = cv2.GaussianBlur(img0, (5,5), 0)

# visualizando a imagem
cv2_imshow(gaussian_blurred)

"""Agora que sabemos o que acontece por tr√°s, podemos usar sem medo essa implementa√ß√£o simples e direta que o OpenCV proporciona, sem muito trabalho, e com apenas uma linha de c√≥digo.

### Motion Blur

Da mesma forma que implementamos o blur acima, tamb√©m podemos implementar um outro tipo de emba√ßado, o *Motion Blur*.

Motion significa movimento, ent√£o esse emba√ßado vai buscar agir de forma a acrescentar um emba√ßado que passe a impress√£o de movimento na imagem.
"""

# implementando o filtro
kernel_motion_blur = np.zeros((15, 15))
kernel_motion_blur[7, :] = np.ones(15)
kernel_motion_blur = kernel_motion_blur / 15

# aplicando o filtro
motion_blurred = cv2.filter2D(img0, -1, kernel_motion_blur)

# plotando a imagem
cv2_imshow(motion_blurred)

"""### Sharpening

O contr√°rio de emba√ßar a foto, seria deixar ela mais bem definida, "afiar" a imagem. E esse √© o conceito do *Sharpening*.

Nosso objetivo aqui √© exatamente esse, melhorar a nitidez, deixar a imagem menos emba√ßada. Para isso, tamb√©m podemos usar o OpenCV.

O processo de sharpening √© usado, normalmente, para melhorar os "limites" dentro da imagem, os *edges*. Existem muitas formas de criar filtros para melhorar as bordas dentro da imagem, mas uma delas pode ser vista aqui embaixo:

<p align="center"><img src="http://media5.datahacker.rs/2020/04/25-279x300.jpg" width="30%" ></p>

Abaixo, podemos ver essa implementa√ß√£o em forma de c√≥digo, onde criamos o array que representa esse filtro de sharpening. Esse filtro tem um centro positivo de 9 e todos os outros pontos possuem o valor -1.

Para esse tipo de filtro, n√≥s n√£o temos uma implementa√ß√£o oficial do OpenCV. Por isso, vamos usar a fun√ß√£o `cv2.filter2D()` que vai processar nossa imagem com um filtro criado por n√≥s, arbitrariamente. Esse filtro √© comumente usado para fazer sharpening em imagens coloridas.
"""

# criando o filtro de sharpening
kernel_sharpening_1 = np.array([[-1,-1,-1],
                                [-1,9,-1],
                                [-1,-1,-1]])

# implementando o filtro
sharpened = cv2.filter2D(img1, -1, kernel_sharpening_1)

# mostrando a imagem
cv2_imshow(sharpened)

"""### Canny Edges
Canny Edge Detection √© um algortimo de detec√ß√£o de bordas bastante popular, que tem implementa√ß√£o dentro do OpenCV.

O Canny Edges √© um algoritmo multi-est√°gio, e esses est√°gios incluem:

* Redu√ß√£o de ru√≠dos
* Busca pelo Gradiente de Intensidade da imagem
* Supress√£o de N√£o-M√°ximos
* Thresholding de Histerese

O OpenCV coloca todos os passos acima em uma √∫nica fun√ß√£o: `cv2.Canny()`.

Para ver mais detalhes t√©cnicos sobre essa fun√ß√£o, recomandamos a leitura da [documenta√ß√£o oficial](https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html).

Abaixo, vamos ver ele em a√ß√£o.
"""

# implementando Canny Edges
edges = cv2.Canny(img1, 50, 240)

# mostrando a imagem
cv2_imshow(edges)

"""Uma outra vers√£o bastante popular de sharpening √© o filtro [Laplacian](https://www.sciencedirect.com/topics/engineering/laplacian-filter). O Laplacian de uma imagem evidencia regi√µes de r√°pida intensidade e √© um exemplo de uma segunda ordem, ou m√©todo de aprimoramento de deriva√ß√£o dupla (em ambas dire√ß√µes).

Esse m√©todo √© particularmente bom em encontrar detalhes finos em uma imagem. Qualquer atributo com descontinuidade evidente vai ser ampliada pelo operador Laplacian.

<p align="center"><img src="https://ars.els-cdn.com/content/image/3-s2.0-B9780128146873000028-f02-06-9780128146873.jpg?_" width="50%" ></p>


A implementa√ß√£o dele pode ser vista abaixo:
"""

# aplicando o filtro
laplacian = cv2.Laplacian(img0, cv2.CV_64F)

# dupla deriva√ß√£o em ambas dire√ß√µes
cv2_imshow(laplacian)

"""Na imagem plotada √© f√°cil identificar o poder desse m√©todo para os detalhes. Ele consegue pegar com precis√£o detalhes da camiseta, dobras no casaco e at√© a fibra do mesmo.

Esse m√©todo pode ser extremamente √∫til em aplica√ß√µes de identifica√ß√£o e acompanhamento de objetos, por exemplo.

### Filtros do Instagram

Agora que temos um amplo arsenal de ferramentas para manipular imagens com o OpenCV, j√° conseguimos entender como s√£o feitos filtros prontos para imagens nas mais diversas plataformas, desde coisas mais simples como um filtro S√©pia para o Instagram, at√© manipula√ß√µes de imagens mais pesadas em programas como o Adobe Photoshop.

Abaixo, vamos ver como pode ser criado um filtro de Instagram usando OpenCV. O c√≥digo original pode ser encontrado [aqui](http://datahacker.rs/004-how-to-smooth-and-sharpen-an-image-in-opencv/).
"""

# criando um filtro s√©pia

(b,g,r)=cv2.split(img1)
r_new = r*0.393 + g*0.769 + b*0.189
g_new = r*0.349 + g*0.686 + b*0.168
b_new = r*0.272 + g*0.534 + b*0.131
sepia = cv2.merge([b_new, g_new, r_new])
cv2_imshow(sepia)

